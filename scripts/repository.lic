=begin

	This script allows you to connect to the Lich server to upload and download scripts,
	the map database, and Lich.

	;repository help

	      author: Tillmen (tillmen@lichproject.org)
	contributors: SpiffyJr (theman@spiffyjr.me)
	        game: any
	        tags: core
	     version: 2.11

	Changelog:
		2.11 (2014-10-02):
			look in data directory when uploading xml files
		2.10 (2014-10-01):
			fix download-updates not checking update times correctly
		2.9 (2014-10-01):
			reduce width of list
		2.8 (2014-10-01):
			added download-updates command
			changed download-lich to preserve file mode of lich.rb on non-Windows
		2.7 (2014-09-29):
			cache file list and reuse if nothing has changed
			added download-lich command

=end

unless $SAFE == 0
	echo "this script must be trusted to work (;trust #{script.name})"
	exit
end

unless defined?(LICH_VERSION) # Lich < 4.5
	LICH_VERSION = $version
end

require 'openssl'
require 'digest/md5'

hostname        = 'lichproject.org'
port            = 7157
ca_cert_data    = "-----BEGIN CERTIFICATE-----\nMIIDlTCCAn2gAwIBAgIJAKuu65i5NsruMA0GCSqGSIb3DQEBCwUAMGExCzAJBgNV\nBAYTAlVTMREwDwYDVQQIDAhJbGxpbm9pczESMBAGA1UECgwJTWF0dCBMb3dlMQ8w\nDQYDVQQDDAZSb290Q0ExGjAYBgkqhkiG9w0BCQEWC21hdHRAaW80LnVzMB4XDTE0\nMDYwNzE3NDUwMFoXDTI0MDYwNDE3NDUwMFowYTELMAkGA1UEBhMCVVMxETAPBgNV\nBAgMCElsbGlub2lzMRIwEAYDVQQKDAlNYXR0IExvd2UxDzANBgNVBAMMBlJvb3RD\nQTEaMBgGCSqGSIb3DQEJARYLbWF0dEBpbzQudXMwggEiMA0GCSqGSIb3DQEBAQUA\nA4IBDwAwggEKAoIBAQCcIRn0IMCNYeL5agKmkdedgJXsIyTJS8qKrY6EvQsq4tt0\nmO3Or9K8IaDl7qFdQ9nfSJ5phNgoCy9wZ9rDWv5FhY5MnnVHGr3fCa7RkMxJFR/N\nwiD4ihQlixOUly76glceyc/6QQS9bNe96evZDstERGAFfzgHY4qAlyurR6mBu9Mb\nyyCRok6xMRnjrbTMNkvvOsuG0sY9ot+SLHGgU3qT7+wVh/CbWcjeF7/Qwa//fbFk\nmq5c1FuvhU3DanSSz+VuWudPFSyZ3r5pYrLMJWsyomDa4gkL2bJ5jya2BWDMXvSS\nCpdQgPDIlClMfAFLd/Ss8ZIGa6uNFcSK6Xca51ClAgMBAAGjUDBOMB0GA1UdDgQW\nBBScbglRiGzz9yzuhgBwFYjgimeByDAfBgNVHSMEGDAWgBScbglRiGzz9yzuhgBw\nFYjgimeByDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQA7MLZYfqam\n5aaSBqQpT6sOGDtVc9koIok59oTQmNXqe+awg2VUnAiesxtLd+FWGUMp8XzHdGWw\nH3O6kAUkPm/in001X7TRAhbgDujfTRbTzxND0XrjuEzDMALs3YpDM1pMXqC7RXWA\n7z+N0gRaUgmh1rMbk/qA3cAfC2dwf2j3NYy3bDw3lMpdyIwAfOQxiZVglYgX3dgT\nU9b//gsUyPCvlpL0mYcmhOOLt6oqQhMJaw1I6A9xMe2kO2L+8KPGK2u1B+P5/Sx0\nFE8LIp5KA3a7yRbOty19NsGR+yW7WwV7BL6c6GOKb/iKJBLYzTmNG6m16hRrxDGj\ntGu91I0ORptB\n-----END CERTIFICATE-----"
cmd             = Array.new
cmd_author      = nil
cmd_password    = nil
cmd_tags        = nil
cmd_sort        = nil
cmd_reverse     = nil
cmd_limit       = nil
cmd_force       = nil
cmd_name        = nil
cmd_game        = nil
cmd_size        = nil
cmd_downloads   = nil
cmd_rating      = nil
cmd_updated     = nil
no_more_options = nil

for var in script.vars[1..-1]
	if no_more_options
		cmd.push(var)
	elsif var == '--'
		no_more_options = true
	elsif var =~ /^--/
		if var =~ /^--author\s*=\s*(.+)/i
			cmd_author = $1
		elsif var =~ /^--password\s*=\s*(.+)/i
			cmd_password = $1
		elsif var =~ /^--sort\s*=\s*(.+)/i
			cmd_sort = $1
		elsif var =~ /^--reverse$/i
			cmd_reverse = true
		elsif var =~ /^--limit\s*=\s*(.+)/i
			cmd_limit = $1
		elsif var =~ /^--force$/i
			cmd_force = true
		elsif var =~ /^--game\s*=\s*(.+)/i
			cmd_game = $1
		elsif var =~ /^--name\s*=\s*(.+)/i
			cmd_name ||= Array.new
			cmd_name.push($1)
		elsif var =~ /^--tags?\s*=\s*(.+)/i
			cmd_tags ||= Array.new
			cmd_tags.push($1)
		elsif var =~ /^--size\s*(>|<|=)\s*([0-9\.]+)(k|m|g)?b?/i
			cmd_size ||= Array.new
			if $3 == 'g'
				cmd_size.push [ $1, ($2.to_f*1073741824).to_i ]
			elsif $3 == 'm'
				cmd_size.push [ $1, ($2.to_f*1048576).to_i ]
			elsif $3 == 'k'
				cmd_size.push [ $1, ($2.to_f*1024).to_i ]
			else
				cmd_size.push [ $1, $2.to_i ]
			end
		elsif var =~ /^--age\s*(>|<)\s*([0-9\.]+)(m|h|d|w|y)?$/i
			cmd_age ||= Array.new
			if $3 == 'y'
				cmd_age.push [ $1, ($2.to_f*60*60*24*365).to_i ]
			elsif $3 == 'w'
				cmd_age.push [ $1, ($2.to_f*60*60*24*7).to_i ]
			elsif $3 == 'd'
				cmd_age.push [ $1, ($2.to_f*60*60*24).to_i ]
			elsif $3 == 'h'
				cmd_age.push [ $1, ($2.to_f*60*60).to_i ]
			elsif $3 == 'm'
				cmd_age.push [ $1, ($2.to_f*60).to_i ]
			else
				cmd_age.push [ $1, $2.to_i ]
			end
		elsif var =~ /^--downloads?\s*(>|<|=)\s*([0-9]+)/i
			cmd_downloads ||= Array.new
			cmd_downloads.push [ $1, $2.to_i ]
		elsif var =~ /^--rating\s*(>|<|=)\s*([0-9\.]+)/i
			cmd_rating ||= Array.new
			cmd_rating.push [ $1, $2.to_f ]
		else
			echo "error: unknown option: #{var}"
			exit
		end
	else
		cmd.push(var)
	end
end

get_comments_from_data = proc { |data|
	begin
		if data =~ /^=begin\r?\n?(.+?)^=end/m
			$1.split("\n")
		else
			comments = Array.new
			data.split("\n").each { |line| if line =~ /^[\t\s]*#/; comments.push(line); elsif line !~ /^[\t\s]*$/; break; end }
			comments
		end
	rescue
		Array.new
	end
}

get_author_from_comments = proc { |comments|
	author = nil
	for line in comments
		if line =~ /^[\s\t#]*author:[\s\t]*([\w,\s\.\d]+)/i
			author = $1.sub(/\s\(.*?\)/, '').strip
			break
		end
	end
	author
}

get_game_from_comments = proc { |comments|
	game = nil
	for line in comments
		if line =~ /^[\s\t#]*game:[\s\t]*([\w,\s\.\d]+)/i
			game = $1.strip
			break
		end
	end
	if game =~ /^Gemstone$/i
		'GS'
	elsif game =~ /^Dragon\s*Realms$/i
		'DR'
	else
		game
	end
}

get_tags_from_comments = proc { |comments|
	tags = nil
	for line in comments
		if line =~ /^[\s\t#]*tags:[\s\t]*([\w,\s\.\d]+)/i
			tags = $1.strip
			break
		end
	end
	tags
}

unmet_lich_requirement = proc { |comments|
	requirement = nil
	current_version = LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.')
	for line in comments
		if line =~ /^[\s\t#]*required:[\s\t]*(.+)/i
			$1.split(',').each { |req|
				if req.strip =~ /^[\s\t]*Lich[\s\t]*(>|<|=|>=|<=)[\s\t]*([0-9\.]+)/i
					op = $1
					version = $2
					needed_version = version.split('.').collect { |num| num.rjust(5, '0') }.join('.')
					if op == '<'
						if current_version >= needed_version
							requirement = "< #{version}"
							break
						end
					elsif op == '>'
						if current_version <= needed_version
							requirement = "> #{version}"
							break
						end
					elsif op == '='
						if current_version != needed_version
							requirement = "= #{version}"
							break
						end
					elsif op == '>='
						if current_version < needed_version
							requirement = ">= #{version}"
							break
						end
					elsif op == '<='
						if current_version > needed_version
							requirement = "<= #{version}"
							break
						end
					end
				end
			}
		end
		break if requirement
	end
	requirement
}

connect = proc {
	begin
		cert_store              = OpenSSL::X509::Store.new
		cert_store.add_cert(OpenSSL::X509::Certificate.new(ca_cert_data))
		ssl_context             = OpenSSL::SSL::SSLContext.new
		ssl_context.cert_store  = cert_store
		ssl_context.verify_mode = OpenSSL::SSL::VERIFY_PEER
		socket                  = TCPSocket.new(hostname, port)
		ssl_socket              = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
		ssl_socket.connect
		if ssl_socket.peer_cert.subject.to_a.find { |n| n[0] == 'CN' }[1] != hostname
			if cmd_force
				echo "warning: server certificate hostname mismatch"
			else
				echo "error: server certificate hostname mismatch"
				ssl_socket.close
				socket.close
				exit
			end
		end
		def ssl_socket.geth
			hash = Hash.new
			gets.scan(/[^\t]+\t[^\t]+(?:\t|\n)/).each { |s| s = s.chomp.split("\t"); hash[s[0].downcase] = s[1] }
			return hash
		end
		def ssl_socket.puth(h)
			puts h.to_a.flatten.join("\t")
		end
	rescue
		ssl_socket.close
		socket.close
		echo "error connecting to server: #{$!}"
		exit
	end
	[ ssl_socket, socket ]
}

get_list = proc {
	request = { 'action' => 'list', 'supported compressions' => 'gzip' }
	request['cached-md5sum'] = Digest::MD5.new.update(Settings['cached-list']).to_s if Settings['cached-list']
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth(request)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
			exit
		elsif response['use-cache']
			nil
		else
			if response['size'].nil? or (response['size'] !~ /^[0-9]+$/) or not response['server time']
				echo "error: unrecognized response from server: #{response.inspect}"
				exit
			elsif response['compression'] and response['compression'] != 'gzip'
				echo "error: unsupported compression method: #{response['compression']}"
				exit
			end
			data = ssl_socket.read(response['size'].to_i)
			if response['compression'] == 'gzip'
				data_gz = data
				StringIO.open(data_gz) { |data_gz_io|
					begin
						gz_reader = Zlib::GzipReader.new(data_gz_io)
						data = gz_reader.read
					ensure
						gz_reader.close
					end
				}
				data_gz = nil
			end
			Settings['cached-list'] = data
			Settings['cached-list-offset'] = Time.now.to_i - response['server time'].to_i
		end
		list = Array.new
		Settings['cached-list'].split("\n").each { |d| list.push(d.split("\t", -1)) }
		headers = list.shift
		if lui = headers.index('last update')
			list.each { |row| row[lui] = row[lui].to_i + Settings['cached-list-offset'] }
		end
		list.unshift(headers)
		list
	ensure
		ssl_socket.close
		socket.close
	end
}

filter_list = proc { |list|
	headers = list.shift
	if cmd_name and (fi = headers.index('file'))
		for name in cmd_name
			list.delete_if { |row| row[fi] !~ /#{name.split(',').collect { |n| Regexp.escape(n) }.join('|')}/i }
		end
	end
	if gi = headers.index('game')
		if cmd_game
			games = cmd_game.split(',').collect { |g| g.downcase.strip }
		elsif XMLData.game =~ /^GS/
			games = ['gs','any']
		elsif XMLData.game =~ /^DR/
			games = ['dr','any']
		else
			games = ['other','any']
		end
		list.delete_if { |row| not games.include?(row[gi]) }
	end
	if cmd_size and (si = headers.index('size'))
		for op,bytes in cmd_size
			if op == '>'
				list.delete_if { |row| row[si].to_i <= bytes }
			elsif op == '<'
				list.delete_if { |row| row[si].to_i >= bytes }
			elsif op == '='
				list.delete_if { |row| row[si].to_i != bytes }
			end
		end
	end
	if cmd_age and (lui = headers.index('last update'))
		now = Time.now.to_i
		for op,seconds in cmd_age
			if op == '>'
				list.delete_if { |row| (now - row[lui].to_i) <= seconds }
			elsif op == '<'
				list.delete_if { |row| (now - row[lui].to_i) >= seconds }
			end
		end
	end
	if cmd_author and (ai = headers.index('author'))
		authors = cmd_author.split(',').collect { |a| a.downcase.gsub(/[^a-z]+/, '') }
		list.delete_if { |row| not authors.include?(row[ai].downcase.gsub(/[^a-z]+/, '')) }
	end
	if cmd_downloads and (di = headers.index('downloads'))
		for op,dc in cmd_downloads
			if op == '>'
				list.delete_if { |row| row[di].to_i <= dc }
			elsif op == '<'
				list.delete_if { |row| row[di].to_i >= dc }
			elsif op == '='
				list.delete_if { |row| row[di].to_i != dc }
			end
		end
	end
	if cmd_rating and (rti = headers.index('rating total')) and (rci = headers.index('rating count'))
		list.delete_if { |row| row[rci].to_i.zero? }
		for op,rate in cmd_rating
			list.delete_if { |row| (row[rti] !~ /^[0-9]+$/) or (row[rci] !~ /^[0-9]+$/) or ( (op == '>') and ((row[rti].to_f / row[rci].to_f) <= rate) ) or ( (op == '<') and ((row[rti].to_f / row[rci].to_f) >= rate) ) or ( (op == '=') and ((row[rti].to_f / row[rci].to_f) != rate) ) }
		end
	end
	if cmd_tags and (ti = headers.index('tags'))
		for tags in cmd_tags
			tags = tags.split(',').collect { |t| t.downcase.gsub(/[^a-z]+/, '') }
			list.delete_if { |row| (tags & (row[ti].split(',').collect { |t| t.downcase.gsub(/[^a-z]+/, '') })).empty? }
		end
	end
	list.unshift(headers)
	list	
}

format_list = proc { |list|
	headers = list.shift
	if (rti = headers.index('rating total')) and (rci = headers.index('rating count'))
		list.each_index { |ri|
			if (list[ri][rti] =~ /^[0-9]+$/) and (list[ri][rci].to_i > 0)
#				list[ri][rti] = "#{(list[ri][rti].to_f / list[ri][rci].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)} (#{list[ri][rti]}/#{list[ri][rci]})"
				list[ri][rti] = "#{(list[ri][rti].to_f / list[ri][rci].to_f).to_s.slice(/^[0-9]+(?:\.[0-9])?/)} (#{list[ri][rci]})"
			else
				list[ri][rti] = String.new
			end
		}
		headers[rti] = 'rating'
		headers.delete_at(rci)
		list.each { |row| row.delete_at(rci) }
	end
	if cmd_sort
		if cmd_sort == 'name'
			cmd_sort = 'file'
		elsif cmd_sort =~ /^(?:last\-?)?updated?$|^age$/
			cmd_sort = 'last update'
		end
		if i = headers.index(cmd_sort)
			if cmd_sort =~ /^(?:size|updated|age|downloads)$/
				list.sort! { |a,b| a[i].to_i <=> b[i].to_i }
			elsif cmd_sort == 'rating'
				list.sort! { |a,b| a[i].to_s.slice(/[0-9\.]+/).to_f <=> b[i].to_s.slice(/[0-9\.]+/).to_f }
			else
				list.sort! { |a,b| a[i] <=> b[i] }
			end
		else
			echo "warning: couldn't find a header named #{cmd_sort} in the list"
		end
	end
	if cmd_reverse
		list.reverse!
	end
	if lui = headers.index('last update')
		list.each_index { |ri|
			list[ri][lui] = "#{Time.at(list[ri][lui].to_i).strftime("%Y-%m-%d %I:%M%p").downcase.gsub(/\s0/,'  ')}"
		}
	end
	if si = headers.index('size')
		list.each_index { |ri|
			list[ri][si] = "#{(list[ri][si].to_f / 1024).to_s.slice(/^[0-9]+(?:\.[0-9])?/)}k"
		}
	end
	if c = headers.index('game')
		games = list.collect { |r| r[c] }
		games.uniq!
		games.delete('any')
		if games.length == 1
			headers.delete_at(c)
			list.each { |r| r.delete_at(c) }
		end
	end
	if (ti = headers.index('tags'))
		list.each_index { |ri|
			if list[ri][ti].length > 15
				list[ri][ti] = "#{list[ri][ti][0,14]}>"
			end
		}
	end
	if (di = headers.index('downloads'))
		headers[di] = 'DLs'
	end
	list.unshift headers
	column_width = Array.new
	list[0].each_index { |i|
		list.each { |r|
			column_width[i] = [column_width[i].to_i,r[i].to_s.length].max
		}
	}
	headers = list.shift
	if cmd_limit
		if cmd_limit =~ /^([0-9]+),([0-9]+)$/
			list = list[($1.to_i),($2.to_i)]
		elsif cmd_limit =~ /^[0-9]+$/
			list = list[0,(cmd_limit.to_i)]
		end
	end
	list.unshift column_width.collect { |c| ''.rjust(c, '-') }
	list.unshift headers
	list.each { |row| row.each_index { |i| row[i] = row[i].rjust(column_width[i]) } }
	list.collect { |row| row.join('   ') }.join("\n")
}

download_lich = proc {
	if LICH_VERSION.split('.').collect { |num| num.rjust(5, '0') }.join('.') < '00004.00006.00000'
		echo "error: Your version of Lich is too old to be updated by this script, but that's ok.  The upgrade to Lich 4.6 involves installing Ruby 2.0 and must be done manually.  Lich 4.6 is in beta and upgrading may cause you problems."
	else
		filename = "#{$lich_dir}#{File.basename($PROGRAM_NAME)}"
		if not File.exists?(filename)
			echo "error: file not found: #{filename}"
		else
			begin
				ssl_socket, socket = connect.call
				ssl_socket.puth('action' => 'download-lich', 'current-md5sum' => Digest::MD5.file(filename).to_s, 'supported compressions' => 'gzip')
				response = ssl_socket.geth
				if response['error']
					if response['error'] == 'already up-to-date'
						echo 'Lich is up-to-date'
					else
						echo "error: server says: #{response['error']}"
					end
				elsif response['compression'] and response['compression'] != 'gzip'
					echo "error: unsupported compression method: #{response['compression']}"
				elsif not response['size'] or not response['version'] or not response['md5sum']
					echo "error: unrecognized response from server: #{response.inspect}"
				else
					response['size'] = response['size'].to_i
					backupfilename = "#{$temp_dir}lich-#{LICH_VERSION}.rb"
					backupfilename.concat('w') if $PROGRAM_NAME =~ /w$/
					tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
					echo "downloading Lich #{response['version']}..."
					File.open(tempfilename, 'wb') { |f|
						(response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
						f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
					}
					if response['compression'] == 'gzip'
						ungzipname = "#{$temp_dir}#{rand(100000000)}"
						File.open(ungzipname, 'wb') { |f|
							Zlib::GzipReader.open(tempfilename) { |f_gz|
								while data = f_gz.read(1_000_000)
									f.write(data)
								end
								data = nil
							}
						}
						File.rename(ungzipname, tempfilename)
					end
					md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
					if md5sum_mismatch and not cmd_force
						echo "error: md5sum mismatch: file likely corrupted in transit"
						File.delete(tempfilename)
					else
						if md5sum_mismatch
							echo "warning: md5sum mismatch: file likely corrupted in transit"
						end
						if defined?(Win32)
							File.rename(filename, backupfilename)
							File.rename(tempfilename, filename)
						else
							# perserves file mode, which might be suid and we can't set that here
							File.open(filename, 'rb') { |r| File.open(backupfilename, 'wb') { |w| w.write(r.read) } }
							File.open(tempfilename, 'rb') { |r| File.open(filename, 'wb') { |w| w.write(r.read) } }
							File.delete(tempfilename)
						end
						echo "Lich has been updated to version #{response['version']}."
						echo "Changes will take effect next time you start Lich."
					end
				end
			ensure
				ssl_socket.close
				socket.close
			end
		end
	end
}

download_mapdb = proc {
	failed = true
	if XMLData.game =~ /^GS/i
		if XMLData.game =~ /^GSF$|^GSPlat$/i
			game = XMLData.game.downcase
		else
			game = 'gsiv'
		end
	elsif XMLData.game =~ /^DR/i
		if XMLData.game =~ /^DRX$|^DRPlat$/i
			game = XMLData.game.downcase
		else
			game = 'dr'
		end
	else
		game = XMLData.game.downcase
	end
	request = { 'action' => 'download-mapdb', 'game' => game, 'supported compressions' => 'gzip' }
	if (current_map = Dir.entries("#{$data_dir}#{XMLData.game}").find_all { |fn| fn =~ /^map\-[0-9]+\.(?:dat|xml)$/ }.sort[-1])
		request['current-md5sum'] = Digest::MD5.file("#{$data_dir}#{XMLData.game}/#{current_map}").to_s
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth(request)
		response = ssl_socket.geth
		if response['error']
			if response['error'] == 'already up-to-date'
				echo 'map database is up-to-date'
			else
				echo "error: server says: #{response['error']}"
			end
		elsif response['compression'] and response['compression'] != 'gzip'
			echo "error: unsupported compression method: #{response['compression']}"
		else
			response['size'] = response['size'].to_i
			newfilename = "#{$data_dir}#{XMLData.game}/map-#{response['timestamp']}.dat"

			tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
			echo 'downloading map database...'
			File.open(tempfilename, 'wb') { |f|
				(response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
				f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
			}
			if response['compression'] == 'gzip'
				ungzipname = "#{$temp_dir}#{rand(100000000)}"
				File.open(ungzipname, 'wb') { |f|
					Zlib::GzipReader.open(tempfilename) { |f_gz|
						while data = f_gz.read(1_000_000)
							f.write(data)
						end
						data = nil
					}
				}
				File.rename(ungzipname, tempfilename)
			end
			md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
			if md5sum_mismatch and not cmd_force
				echo "error: md5sum mismatch: file likely corrupted in transit"
				File.delete(tempfilename)
			else
				if md5sum_mismatch
					echo "warning: md5sum mismatch: file likely corrupted in transit"
				end
				File.rename(tempfilename, newfilename)
				failed = false
			end
		end
	ensure
		ssl_socket.close
		socket.close
	end
	unless failed
		# rename map files with a higher timestamp than the just downloaded map, because the user probably wants to use the map they just downloaded
		Dir.entries("#{$data_dir}#{XMLData.game}").each { |fn|
			if (fn =~ /^map\-([0-9]+)\.(?:dat|xml)$/) and ($1.to_i > response['timestamp'].to_i)
				File.rename("#{$data_dir}#{XMLData.game}/#{fn}", "#{$data_dir}#{XMLData.game}/#{fn}.bak")
			end
		}
		echo 'loading map database...'
		Map.reload
		image_filenames = Array.new
		Map.list.each { |room| image_filenames.push(room.image) if room.image and not image_filenames.include?(room.image) }
		Dir.mkdir("#{$lich_dir}maps") unless File.exists?("#{$lich_dir}maps")
		image_filenames.delete_if { |fn| File.exists?("#{$lich_dir}maps/#{fn}") }
		unless image_filenames.empty?
			echo 'downloading missing map images...'
			begin
				ssl_socket, socket = connect.call
				ssl_socket.puth('action' => 'download-mapdb-images', 'files' => image_filenames.join('/'))
				loop {
					response = ssl_socket.geth
					if response['error']
						echo "error: server says: #{response['error']}"
						break
					elsif response['success']
						break
					elsif not response['file'] or not response['size'] or not response['md5sum']
						echo "error: unrecognized response from server: #{response.inspect}"
						break
					end
					response['size'] = response['size'].to_i
					tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
					echo "downloading #{response['file']}..."
					File.open(tempfilename, 'wb') { |f|
						(response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
						f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
					}
					md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
					if md5sum_mismatch and not cmd_force
						echo "error: md5sum mismatch: file likely corrupted in transit"
						File.delete(tempfilename)
					else
						if md5sum_mismatch
							echo "warning: md5sum mismatch: file likely corrupted in transit"
						end
						File.rename(tempfilename, "#{$lich_dir}maps/#{response['file']}")
					end
				}
			ensure
				ssl_socket.close
				socket.close
			end
		end
		echo 'done'
	end
}

download_file = proc { |file,game|
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'download', 'file' => file, 'game' => game, 'supported compressions' => 'gzip')
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
			false
		elsif (response['file'] != file) or (response['size'] !~ /^[0-9]+$/)
			echo 'error: out of cheese 6'
			false
		elsif response['compression'] and response['compression'] != 'gzip'
			echo "error: unsupported compression method: #{response['compression']}"
			false
		else
			response['size'] = response['size'].to_i
			if file =~ /\.xml$/i
				newfilename = "#{$data_dir}#{file}"
			else
				newfilename = "#{$script_dir}#{file}"
			end
			tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
			File.open(tempfilename, 'wb') { |f|
				(response['size'] / 1_000_000).times { f.write(ssl_socket.read(1_000_000)) }
				f.write(ssl_socket.read(response['size'] % 1_000_000)) unless (response['size'] % 1_000_000) == 0
			}
			if response['compression'] == 'gzip'
				ungzipname = "#{$temp_dir}#{rand(100000000)}"
				File.open(ungzipname, 'wb') { |f|
					Zlib::GzipReader.open(tempfilename) { |f_gz|
						while data = f_gz.read(1_000_000)
							f.write(data)
						end
						data = nil
					}
				}
				File.rename(ungzipname, tempfilename)
			end
			md5sum_mismatch = (Digest::MD5.file(tempfilename).to_s != response['md5sum'])
			if md5sum_mismatch and not cmd_force
				echo "error: md5sum mismatch: file likely corrupted in transit"
				File.delete(tempfilename)
				false
			else
				if md5sum_mismatch
					echo "warning: md5sum mismatch: file likely corrupted in transit"
				end
				failed_requirement = unmet_lich_requirement.call(File.open(tempfilename, 'rb') { |f| get_comments_from_data.call(f.read(20_000)) })
				if failed_requirement and not cmd_force
					echo "error: #{file} requires Lich version #{failed_requirement}; your current Lich version is #{LICH_VERSION}"
					File.delete(tempfilename)
					false
				else
					if failed_requirement
						echo "warning: #{file} requires Lich version #{failed_requirement}; your current Lich version is #{LICH_VERSION}"
					end
					File.rename(tempfilename, newfilename)
					true
				end
			end
		end
	ensure
		ssl_socket.close
		socket.close
	end
}



#
# list
#
if cmd[0] =~ /^list$/i
	respond "\n#{format_list.call(filter_list.call(get_list.call))}\n\n"

#
# list-updates
#
elsif cmd[0] =~ /^list-?update[sd]$/i
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (lui = headers.index('last update')) and (fi = headers.index('file'))
		echo 'error: list is missing headers'
		exit
	end
	list.delete_if { |row| 
		if (row[fi] =~ /\.xml$/i) and (LICH_VERSION.split('.').collect { |n| n.rjust(5,'0') }.join('.') >= '00004.00006.00000')
			not File.exists?("#{$data_dir}#{row[fi]}") or ((File.mtime("#{$data_dir}#{row[fi]}").to_i + 15) > row[lui].to_i)
		else
			not File.exists?("#{$script_dir}#{row[fi]}") or ((File.mtime("#{$script_dir}#{row[fi]}").to_i + 15) > row[lui].to_i)
		end
	}
	list.unshift(headers)
	respond "\n#{format_list.call(list)}\n\n"


#
# list-new
#
elsif cmd[0] =~ /^list-?new$/i
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file'))
		echo 'error: list is missing headers'
		exit
	end
	list.delete_if { |row|
		if row[fi] =~ /\.xml$/i
			File.exists?("#{$data_dir}#{row[fi]}")
		else
			File.exists?("#{$script_dir}#{row[fi]}")
		end
	}
	list.unshift(headers)
	respond "\n#{format_list.call(list)}\n\n"


#
# list-tags
#
elsif cmd[0] =~ /^list-?tags?$/i
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless ti = headers.index('tags')
		echo 'error: list is missing headers'
		exit
	end
	tags = Hash.new
	list.each { |row| row[ti].split(',').each { |t| tags[t.downcase.gsub(/[^a-z]+/, '')] = t } }
	if tags.empty?
		respond "\ntags: (none)\n\n"
	else
		respond "\ntags: #{tags.values.join(', ')}\n\n"
	end


#
# info
#
elsif (cmd[0] =~ /^info$/i) and cmd[1]
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file')) and (gi = headers.index('game'))
		echo 'error: list is missing headers'
		exit
	end
	exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
	if exact_name_list.length > 0
		list = exact_name_list
	else
		list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
	end
	if list.empty?
		echo "error: file not found"
	elsif list.length > 1
		list.unshift(headers)
		respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
	else
		file = list[0][fi]
		game = list[0][gi]
		list.unshift(headers)
		begin
			ssl_socket, socket = connect.call
			ssl_socket.puth('action' => 'inspect', 'file' => file, 'game' => game)
			response = ssl_socket.geth
			if response['error']
				echo "error: server says: #{response['error']}"
				exit
			elsif (response['size'] !~ /^[0-9]+$/)
				echo 'error: out of cheese 4'
				exit
			end
			data = ssl_socket.read(response['size'].to_i)
		ensure
			ssl_socket.close
			socket.close
		end
		respond "\n#{format_list.call(list)}\n\n#{data}\n\n"
	end


#
# download
#
elsif (cmd[0] =~ /^download$/i) and cmd[1]
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file')) and (gi = headers.index('game'))
		echo 'error: list is missing headers'
		exit
	end
	exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
	if exact_name_list.length > 0
		list = exact_name_list
	else
		list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
	end
	if list.empty?
		echo "error: file not found"
	elsif list.length > 1
		list.unshift(headers)
		respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
	else
		echo "downloading #{list[0][fi]} in 3 seconds... (;k #{script.name} to cancel)"
		sleep 3
		if download_file.call(list[0][fi], list[0][gi])
			echo 'done'
		end
	end


#
# download-updates
#
elsif (cmd[0] =~ /^download-?update[ds]$/i)
	if Settings['updatable'].nil?
		echo "error: download-updates has not been set up; look for set-updatable and unset-updatable commands in ;#{script.name} help"
		exit
	end
	Settings['updatable'][:scripts] ||= Array.new
	Settings['updatable'][:mapdb] ||= Hash.new
	if Settings['updatable'][:lich]
		download_lich.call
	end
	if Settings['updatable'][:mapdb][XMLData.game]
		download_mapdb.call
	end
	unless Settings['updatable']['scripts'].empty?
		list = get_list.call
		headers = list.shift
		unless (fi = headers.index('file')) and (gi = headers.index('game')) and (lui = headers.index('last update')) and (ai = headers.index('author'))
			echo 'error: list is missing headers'
		else
			no_updates = true
			for local_info in (Settings['updatable'][:scripts])
				if remote_info = list.find { |rinfo| (rinfo[fi] == local_info[:filename]) and (rinfo[gi] == local_info[:game]) }
					if (local_info[:filename] =~ /\.xml$/i) and (LICH_VERSION.split('.').collect { |n| n.rjust(5,'0') }.join('.') >= '00004.00006.00000')
						updated = !File.exists?("#{$data_dir}#{local_info[:filename]}") || (File.mtime("#{$data_dir}#{local_info[:filename]}").to_i < remote_info[lui].to_i)
					else
						updated = !File.exists?("#{$script_dir}#{local_info[:filename]}") || (File.mtime("#{$script_dir}#{local_info[:filename]}").to_i < remote_info[lui].to_i)
					end
					if updated
						if (remote_info[ai] != local_info[:author]) and not cmd_force
							echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: skipping"
						else
							if remote_info[ai] != local_info[:author]
								echo "warning: author of #{local_info[:filename]} changed from #{local_info[:author]} to #{remote_info[ai]}: downloading anyway"
							end
							echo "downloading #{local_info[:filename].sub(/\.lic$/,'')}..."
							download_file.call(local_info[:filename], local_info[:game])
							no_updates = false
						end
					end
				else
					# file is not in the repository
				end
			end
			if no_updates
				echo 'scripts are up-to-date'
			else
				echo 'done'
			end
		end
	end


#
# settings for download-updates
#
elsif (cmd[0] =~ /^show-?updat(?:e|able)$/i)
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:scripts] ||= Array.new
	Settings['updatable'][:mapdb] ||= Hash.new
	output = "\n"
	output.concat "      Lich: #{Settings['updatable'][:lich] ? 'on' : 'off'}\n"
	output.concat "    map db: #{Settings['updatable'][:mapdb][XMLData.game] ? 'on' : 'off'}\n"
	if Settings['updatable'][:scripts].empty?
		output.concat "   scripts: (none)\n"
	else
		output.concat "   scripts: #{Settings['updatable'][:scripts].collect { |s| s[:filename].sub(/\.lic$/,'') }.join(', ')}\n"
	end
	output.concat "\n"
	respond output
elsif (cmd[0] =~ /^set-?updat(?:e|able)$/i) and cmd[1]
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file')) and (gi = headers.index('game')) and (ai = headers.index('author'))
		echo 'error: list is missing headers'
		exit
	end
	exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
	if exact_name_list.length > 0
		list = exact_name_list
	else
		list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
	end
	if list.empty?
		echo "error: file not found"
	elsif list.length > 1
		list.unshift(headers)
		respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
	else
		info = { :filename => list[0][fi], :game => list[0][gi], :author => list[0][ai] }
		Settings['updatable'] ||= Hash.new
		Settings['updatable'][:scripts] ||= Array.new
		if Settings['updatable'][:scripts].include?(info)
			echo "#{info[:filename]} is already set as updatable"
		else
			Settings['updatable'][:scripts].push(info)
			echo "the download-updates command will download #{info[:filename]} when there's and update"
		end
	end
elsif (cmd[0] =~ /^unset-?updat(?:e|able)$/i) and cmd[1]
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:scripts] ||= Array.new
	if info = (Settings['updatable'][:scripts].find { |i| i[:filename] == cmd[1] } || Settings['updatable'][:scripts].find { |i| i[:filename] =~ /^#{cmd[1]}/i })
		echo "the download-updates command will ignore updates for #{info[:filename]}"
		Settings['updatable'][:scripts].delete(info)
	else
		echo "could not find #{cmd[1]} in the updatable list"
	end
elsif (cmd[0] =~ /^set-?lich-?updat(?:e|able)$|^set-?updat(?:e|able)-?lich$/i)
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:lich] = true
	echo "the download-updates command will download Lich when there's an update"
elsif (cmd[0] =~ /^unset-?lich-?updat(?:e|able)$|^unset-?updat(?:e|able)-?lich$/i)
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:lich] = false
	echo 'the download-updates command will ignore updates for Lich'
elsif (cmd[0] =~ /^set-?map(?:db)?-?updat(?:e|able)$|^set-?updat(?:e|able)-?map(?:db)?$/i)
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:mapdb] ||= Hash.new
	Settings['updatable'][:mapdb][XMLData.game] = true
	echo "the download-updates command will download the #{XMLData.game} map database when there's an update"
elsif (cmd[0] =~ /^unset-?map(?:db)?-?updat(?:e|able)$|^unset-?updat(?:e|able)-?map(?:db)?$/i)
	Settings['updatable'] ||= Hash.new
	Settings['updatable'][:mapdb] ||= Hash.new
	Settings['updatable'][:mapdb][XMLData.game] = false
	echo "the download-updates command will ignore updates for the #{XMLData.game} map database"


#
# upload
#
elsif (cmd[0] =~ /^upload$/i) and cmd[1]
	if File.exists?("#{$script_dir}#{cmd[1]}")
		file = cmd[1]
		filename = "#{$script_dir}#{cmd[1]}"
	elsif File.exists?("#{$script_dir}#{cmd[1]}.lic")
		file = "#{cmd[1]}.lic"
		filename = "#{$script_dir}#{cmd[1]}.lic"
	elsif (cmd[1] =~ /\.xml$/i) and File.exists?("#{$data_dir}#{cmd[1]}")
		file = "#{cmd[1]}"
		filename = "#{$data_dir}#{cmd[1]}"
	else
		echo "error: could not find #{cmd[1]}"
		exit
	end
	_filename = filename
	md5sum    = Digest::MD5.file(filename).to_s
	comments  = File.open(filename, 'rb') { |f| get_comments_from_data.call(f.read(20_000)) }
	author    = (cmd_author || get_author_from_comments.call(comments) || Char.name)
	game      = (cmd_game || get_game_from_comments.call(comments) || (if XMLData.game =~ /^GS/; 'GS'; elsif XMLData.game =~ /^DR/; 'DR'; else; 'other'; end))
	password  = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	if password.nil?
		echo "error: no password is saved for author #{author}"
		echo "If that's not the author name you want for this script, specify a different name by adding \"author: NAME\" to the comments at the top of your script, or add \"--author=NAME\" to the upload command."
		echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
		exit
	end
	tags     = (cmd_tags.join(',') || get_tags_from_comments.call(comments))
	size     = File.stat(filename).size
	request  = { 'action' => 'upload', 'file' => file, 'game' => game, 'size' => size, 'author' => author, 'password' => password, 'md5sum' => md5sum, 'tags' => tags }
	delete_filename = false
	if size > 5000
		tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
		File.open(filename, 'rb') { |f|
			Zlib::GzipWriter.open(tempfilename) { |f_gz|
				while data = f.read(1_000_000)
					f_gz.write(data)
				end
				data = nil
			}
		}
		filename = tempfilename
		delete_filename = true
		size = File.stat(filename).size
		request['size'] = size
		request['compression'] = 'gzip'
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth(request)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
			exit
		elsif not response['continue']
			echo "error: unrecognized response from server: #{response.inspect}"
			exit
		end
		if cmd_password
			Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
			echo "password saved for author #{author}"
		end
		File.open(filename, 'rb') { |f|
			(size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
			ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
		}
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			echo 'upload complete'
		else
			echo "error: unrecognized response from server: #{response.inspect}"
		end
	ensure
		ssl_socket.close
		socket.close
		File.delete(filename) if delete_filename
	end


#
# delete
#
elsif (cmd[0] =~ /^delete$/i) and cmd[1]
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file')) and (gi = headers.index('game')) and (ai = headers.index('author'))
		echo 'error: list is missing headers'
		exit
	end
	exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
	if exact_name_list.length > 0
		list = exact_name_list
	else
		list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
	end
	if list.empty?
		echo "error: file not found"
	elsif list.length > 1
		list.unshift(headers)
		respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
	else
		file = list[0][fi]
		game = list[0][gi]
		author = list[0][ai]
		password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
		if password.nil?
			echo "error: no password is saved for author #{author}; specify a password by adding \"--password=PASSWORD\" to the delete command"
			exit
		end
		echo "deleting #{file} in 5 seconds... (;k #{script.name} to cancel)"
		sleep 5
		begin
			ssl_socket, socket = connect.call
			ssl_socket.puth('action' => 'delete', 'file' => file, 'game' => game, 'author' => author, 'password' => password)
			response = ssl_socket.geth
			if response['error']
				echo "error: server says: #{response['error']}"
			elsif response['success']
				if cmd_password
					Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
					echo "password saved for author #{author}"
				end
				echo 'done'
			else
				echo "error: unrecognized response from server: #{response.inspect}"
			end
		ensure
			ssl_socket.close
			socket.close
		end
	end


#
# rate
#
elsif (cmd[0] =~ /^rate$/i) and cmd[1] and (cmd[2] =~ /^(?:[1-9]|10)$/)
	list = filter_list.call(get_list.call)
	headers = list.shift
	unless (fi = headers.index('file')) and (gi = headers.index('game'))
		echo 'error: list is missing headers'
		exit
	end
	exact_name_list = list.find_all { |row| row[fi].downcase == cmd[1].downcase }
	if exact_name_list.length > 0
		list = exact_name_list
	else
		list.delete_if { |row| row[fi] !~ /^#{cmd[1]}/i }
	end
	if list.empty?
		echo "error: file not found"
	elsif list.length > 1
		list.unshift(headers)
		respond "\nMultiple files match: be more specific\n\n#{format_list.call(list)}\n\n"
	else
		file = list[0][fi]
		game = list[0][gi]
		begin
			ssl_socket, socket = connect.call
			ssl_socket.puth('action' => 'rate', 'file' => file, 'game' => game, 'rating' => cmd[2])
			response = ssl_socket.geth
			if response['error']
				echo "error: server says: #{response['error']}"
				exit
			elsif response['success']
				echo 'Thank you for rating this script.'
				exit
			end
		ensure
			ssl_socket.close
			socket.close
		end
	end


#
# change password
#
elsif cmd[0] =~ /^(?:new|change)-?password$/i and cmd[1]
	author = (cmd_author || Char.name)
	password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	if password.nil?
		echo "error: no password is saved for author #{author}; specify a password by adding \"--password=OLDPASSWORD\" to the change-password command (or if this author name has not been used before, the initial password must be set with an upload command)"
		exit
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'change password', 'author' => author, 'password' => password, 'new password' => cmd[1])
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			echo 'your password has been changed on the server'
			Settings["password:#{author.gsub(/[^a-z]/, '').downcase}"] = cmd[1]
			echo "password saved for author #{author}"
		end
	ensure
		ssl_socket.close
		socket.close
	end


#
# checkout-mapdb
#
elsif (cmd[0] =~ /^checkout-?map(?:db)?$/i)
	if XMLData.game =~ /^GSF$|^GSPlat$|^GSIV$|^DR$|^DRX$|^DRPlat$/i
		game = XMLData.game.downcase
	else
		echo 'error: unknown game'
		exit
	end
	author = (cmd_author || Char.name)
	password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	if password.nil?
		echo "error: no password is saved for author #{author}"
		echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
		echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
		exit
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'checkout-mapdb', 'author' => author, 'password' => password, 'game' => game)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			if cmd_password
				Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
				echo "password saved for author #{author}"
			end
			echo "success: now you should (within 24 horus):     ;#{script.name} download-mapdb     edit your map database     ;#{script.name} upload-mapdb"
		end
	ensure
		ssl_socket.close
		socket.close
	end


#
# relase-mapdb
#
elsif (cmd[0] =~ /^release-?map(?:db)?$/i)
	author = (cmd_author || Char.name)
	password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	if password.nil?
		echo "error: no password is saved for author #{author}"
		echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
		echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
		exit
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'release-mapdb', 'author' => author, 'password' => password, 'game' => XMLData.game.downcase)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			if cmd_password
				Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
				echo "password saved for author #{author}"
			end
			echo 'success: other people can work on the map database now'
		end
	ensure
		ssl_socket.close
		socket.close
	end


#
# approve-mapdb
#
elsif (cmd[0] =~ /^approve-?map(?:db)?$/i)
	author = (cmd_author || Char.name)
	password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	unless (game = cmd[1]) and (timestamp = cmd[2])
		echo "You're doing it wrong."
		exit
	end
	if password.nil?
		echo "error: no password is saved for author #{author}"
		echo "If that's not the author name you want to use, specify a different name by adding \"--author=NAME\" to the command."
		echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the command."
		exit
	end
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'approve-mapdb', 'author' => author, 'password' => password, 'game' => game, 'timestamp' => timestamp)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			if cmd_password
				Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
				echo "password saved for author #{author}"
			end
			echo 'success'
		end
	ensure
		ssl_socket.close
		socket.close
	end


#
# upload-mapdb
#
elsif (cmd[0] =~ /^upload-?map(?:db)?$/i)
	if XMLData.game =~ /^GSF$|^GSPlat$|^GSIV$|^DR$|^DRX$|^DRPlat$/i
		game = XMLData.game.downcase
	else
		echo 'error: unknown game'
		exit
	end
	echo 'saving map database...'
	Map.save
	filename = Dir.entries("#{$data_dir}#{XMLData.game}").find_all { |fn| fn =~ /^map\-[0-9]+\.(?:dat|xml)$/ }.collect { |fn| "#{$data_dir}#{XMLData.game}/#{fn}" }.sort[-1]
	unless File.exists?(filename)
		echo 'error'
		exit
	end
	md5sum   = Digest::MD5.file(filename).to_s
	author   = (cmd_author || Char.name)
	password = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	if password.nil?
		echo "error: no password is saved for author #{author}"
		echo "If that's not the author name you want, specify a different name by adding \"--author=NAME\" to the command."
		echo "Otherwise, specify a password by adding \"--password=NEWPASSWORD\" to the upload command."
		exit
	end
	size     = File.stat(filename).size
	request  = { 'action' => 'upload-mapdb', 'game' => game, 'author' => author, 'password' => password, 'md5sum' => md5sum }

	echo 'compressing map database...'
	tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
	File.open(filename, 'rb') { |f|
		Zlib::GzipWriter.open(tempfilename) { |f_gz|
			while data = f.read(1_000_000)
				f_gz.write(data)
			end
			data = nil
		}
	}
	size = File.stat(tempfilename).size
	request['size'] = size
	request['compression'] = 'gzip'

	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth(request)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
			exit
		elsif not response['continue']
			echo "error: unrecognized response from server: #{response.inspect}"
			exit
		end
		if cmd_password
			Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
			echo "password saved for author #{author}"
		end
		echo 'uploading map database...'
		File.open(tempfilename, 'rb') { |f|
			(size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
			ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
		}
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			echo 'upload complete'
		else
			echo "error: unrecognized response from server: #{response.inspect}"
		end
	ensure
		ssl_socket.close
		socket.close
		File.delete(tempfilename)
	end

	image_filenames = Array.new
	Map.list.each { |room| image_filenames.push(room.image) if room.image and not image_filenames.include?(room.image) }
	image_filenames.each { |fn|
		unless fn =~ /\.(?:png|jpg|gif)$/i
			echo "warning: ignoring #{fn} (map images should have a .png or .jpg file extension)"
		end
		unless File.exists?("#{$lich_dir}maps/#{fn}")
			echo "warning: ignoring #{fn} (file not found in #{$lich_dir}/maps)"
		end
	}
	image_filenames.delete_if { |fn| (fn !~ /\.(?:png|jpg|gif)$/i) or not File.exists?("#{$lich_dir}maps/#{fn}") }
	image_filenames = image_filenames.join('/')

	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'upload-mapdb-images', 'files' => image_filenames)
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['need-images']
			for filename in response['need-images'].split('/')
				echo "uploading #{filename}..."
				size = File.stat("#{$lich_dir}maps/#{filename}").size
				ssl_socket.puth('file' => filename, 'size' => size, 'md5sum' => Digest::MD5.file("#{$lich_dir}maps/#{filename}").to_s)
				response = ssl_socket.geth
				if response['error']
					echo "error: server says: #{response['error']}"
					break
				elsif not response['continue']
					echo "error: unrecognized response from server: #{response.inspect}"
					break
				end
				File.open("#{$lich_dir}maps/#{filename}", 'rb') { |f|
					(size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
					ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
				}
				response = ssl_socket.geth
				if response['error']
					echo "error: server says: #{response['error']}"
				elsif not response['success']
					echo "error: unrecognized response from server: #{response.inspect}"
				end
			end
			echo 'done'
		elsif response['success']
			nil
		else
			echo "error: unrecognized response from server: #{response.inspect}"
		end
	ensure
		ssl_socket.close
		socket.close
	end


#
# download-mapdb
#
elsif (cmd[0] =~ /^download-?map(?:db)?$/i)
	download_mapdb.call
	

#
# upload-lich
#
elsif (cmd[0] =~ /^upload-?lich$/i)
	filename = "#{$lich_dir}#{File.basename($PROGRAM_NAME)}"
	unless File.exists?(filename)
		echo "error: file not found: #{filename}"
		exit
	end
	tempfilename = "#{$temp_dir}#{rand(100000000)}.repo"
	File.open(filename, 'rb') { |f|
		Zlib::GzipWriter.open(tempfilename) { |f_gz|
			while data = f.read(1_000_000)
				f_gz.write(data)
			end
			data = nil
		}
	}
	size = File.stat(tempfilename).size
	author    = (cmd_author || Char.name)
	password  = (cmd_password || Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"])
	begin
		ssl_socket, socket = connect.call
		ssl_socket.puth('action' => 'upload-lich', 'author' => author, 'password' => password, 'version' => LICH_VERSION, 'size' => size.to_s, 'md5sum' => Digest::MD5.file(filename).to_s, 'compression' => 'gzip')
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
			exit
		elsif not response['continue']
			echo "error: unrecognized response from server: #{response.inspect}"
			exit
		end
		if cmd_password
			Settings["password:#{author.downcase.gsub(/[^a-z]/, '')}"] = cmd_password
			echo "password saved for author #{author}"
		end
		File.open(tempfilename, 'rb') { |f|
			(size / 1_000_000).times { ssl_socket.write(f.read(1_000_000)) }
			ssl_socket.write(f.read(size % 1_000_000)) unless (size % 1_000_000) == 0
		}
		response = ssl_socket.geth
		if response['error']
			echo "error: server says: #{response['error']}"
		elsif response['success']
			echo 'upload complete'
		else
			echo "error: unrecognized response from server: #{response.inspect}"
		end
		File.delete(tempfilename)
	ensure
		ssl_socket.close
		socket.close
	end


#
# download-lich
#
elsif (cmd[0] =~ /^download-?lich$/i)
	download_lich.call


#
# gui
#
elsif cmd[0] =~ /^gui$/i
	echo 'fixme'


#
# help
#
elsif cmd[0] =~ /^help$/i
		output = "\n"
		output.concat "usage:\n"
		output.concat "\n"
		output.concat "   #{$clean_lich_char}#{script.name} COMMAND OPTIONS\n"
		output.concat "\n"
		output.concat "commands:\n"
		output.concat "\n"
		output.concat "   list                      show files you can download\n"
		output.concat "   list-updates              show files that you have and there's an update for\n"
		output.concat "   list-new                  show files that you don't have\n"
		output.concat "   list-tags                 show all the tags currently in use\n"
		output.concat "   info FILENAME             show information about a file\n"
		output.concat "   download FILENAME         download a file\n"
		output.concat "   rate FILENAME NUMBER      rate a file\n"
		output.concat "   upload FILENAME           upload a file to the server\n"
		output.concat "   delete FILENAME           delete a file from the server\n"
		output.concat "   change-password NEWPASS   change your repository password\n"
		output.concat "   download-lich             download the latest version of Lich\n"
		output.concat "   download-mapdb            download the latest map database\n"
		output.concat "   checkout-mapdb            must be done before editing the map database\n"
		output.concat "   release-mapdb             if you checkout-mapdb and change your mind\n"
		output.concat "   upload-mapdb              upload your changes to the map database\n"
		output.concat "   download-updates          downloads any available updates to scripts/lich/mapdb\n"
		output.concat "                             if set as updatable with the set-updatable commands\n"
		output.concat "   show-updatable            shows your current settings for download-updates\n"
		output.concat "   set-updatable FILENAME    download updates for FILENAME (when using download-updates)\n"
		output.concat "   set-lich-updatable        download updates for Lich (download-updates)\n"
		output.concat "   set-mapdb-updatable       download updates for the map database (download-updates)\n"
		output.concat "   unset-updatable FILENAME  ignore updates to FILENAME\n"
		output.concat "   unset-lich-updatable      ignore updates to Lich\n"
		output.concat "   unset-mapdb-updatable     ignore updates to the map database\n"
		output.concat "\n"
		output.concat "options:\n"
		output.concat "\n"
		output.concat "   --name=TEXT[,TEXT]        only list files whose name contain TEXT\n"
		output.concat "   --game=CODE[,CODE]        complicated\n"
		output.concat "   --sort=TEXT               sort list by name,age,size,downloads,rating\n"
		output.concat "   --reverse                 show the list in reverse order\n"
		output.concat "   --limit=NUMBER            show at most NUMBER files in the list\n"
		output.concat "   --limit=OFFSET,NUMBER     show at most NUMBER files after skipping OFFSET files\n"
		output.concat "   --author=TEXT             specify the author of the file for uploading or listing\n"
		output.concat "   --password=TEXT           specify the password for the author for uploading\n"
		output.concat "   --size>NUMBER[k|m|g]      only list files larger than NUMBER bytes (or specified unit)\n"
		output.concat "   --size<NUMBER[k|m|g]      only list files smaller than NUMBER bytes (or specified unit)\n"
		output.concat "   --age>NUMBER[m|h|d|w|y]   only list files updated less than NUMBER seconds (or specified unit) ago\n"
		output.concat "   --age<NUMBER[m|h|d|w|y]   only list files updated more than NUMBER seconds (or specified unit) ago\n"
		output.concat "   --downloads>NUMBER        only list files with more than NUMBER downloads\n"
		output.concat "   --downloads<NUMBER        only list files with less than NUMBER downloads\n"
		output.concat "   --downloads=NUMBER        only list files with exactly NUMBER downloads\n"
		output.concat "   --rating>NUMBER           only list files with a rating higher than NUMBER\n"
		output.concat "   --rating<NUMBER           only list files with a rating lower than NUMBER\n"
		output.concat "   --rating=NUMBER           only list files with a rating equal to NUMBER\n"
		output.concat "   --tags=TEXT[,TEXT]        only list files with the specified tags\n"
		output.concat "   --force                   ignore md5sum checks and script requirements\n"
   		output.concat "\n"
		respond output


#
# everything else
#
else
	echo "error: unrecognized command.  Try #{$clean_lich_char}#{script.name} help"


end
